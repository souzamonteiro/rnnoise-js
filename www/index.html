<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1a2a6c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>RNNoise Audio Denoiser</title>
    <link rel="icon" href="icons/favicon.ico" type="image/x-icon">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icons/icon-152x152.png">

    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --danger-color: #e74c3c;
            --light-gray: #f5f5f5;
            --dark-gray: #333;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--dark-gray);
            background-color: #f9f9f9;
            padding: 20px;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        h1 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }
        
        .description {
            color: #666;
            margin-bottom: 20px;
        }
        
        .upload-section {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            margin-bottom: 30px;
            transition: border-color 0.3s;
        }
        
        .upload-section.dragover {
            border-color: var(--primary-color);
            background-color: rgba(52, 152, 219, 0.05);
        }
        
        .upload-section p {
            margin-bottom: 20px;
        }
        
        .btn {
            display: inline-block;
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
            font-weight: 500;
        }
        
        .btn:hover {
            background-color: #2980b9;
        }
        
        .btn:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        
        .btn-success {
            background-color: var(--secondary-color);
        }
        
        .btn-success:hover {
            background-color: #27ae60;
        }
        
        .btn-danger {
            background-color: var(--danger-color);
        }
        
        .btn-danger:hover {
            background-color: #c0392b;
        }
        
        .audio-controls {
            margin-top: 30px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        audio {
            width: 100%;
            margin-top: 10px;
        }
        
        .progress-container {
            margin-top: 20px;
            display: none;
        }
        
        .progress-bar {
            height: 20px;
            background-color: #eee;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .progress {
            height: 100%;
            background-color: var(--primary-color);
            width: 0%;
            transition: width 0.3s;
        }
        
        .status-text {
            text-align: center;
            margin-bottom: 10px;
        }
        
        .error-message {
            color: var(--danger-color);
            margin-top: 10px;
            padding: 10px;
            background-color: rgba(231, 76, 60, 0.1);
            border-radius: 4px;
            display: none;
        }
        
        .file-info {
            margin-top: 10px;
            font-size: 14px;
            color: #777;
        }
        
        .comparison {
            display: flex;
            gap: 20px;
            margin-top: 30px;
        }
        
        .comparison-item {
            flex: 1;
            padding: 15px;
            border-radius: 8px;
            background-color: var(--light-gray);
        }
        
        .comparison-item h3 {
            margin-bottom: 10px;
            text-align: center;
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }
            
            .control-group {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .comparison {
                flex-direction: column;
            }
        }
        
        .log-output {
            margin-top: 30px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            background-color: #f8f8f8;
            font-family: monospace;
            font-size: 14px;
            display: none;
        }
        
        .info-message {
            background-color: #e7f3ff;
            border: 1px solid #b3d9ff;
            color: #004085;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ðŸŽ¤ RNNoise Audio Denoiser</h1>
            <p class="description">Upload a WAV file to remove noise using RNNoise</p>
        </header>
        
        <div class="info-message">
            <strong>Note:</strong> This program implements a simple version of the RNNoise CLI
        </div>
        
        <div class="upload-section" id="uploadSection">
            <p>Drag & drop a WAV file here or click to select</p>
            <input type="file" id="audioFileInput" accept=".wav" style="display: none;">
            <button class="btn" id="selectFileBtn">Select Audio File</button>
        </div>
        
        <div class="error-message" id="errorMessage"></div>
        
        <div id="fileInfo" class="file-info"></div>
        
        <div class="audio-controls" id="audioControls" style="display: none;">
            <div class="control-group">
                <button class="btn" id="processBtn">Process Audio with RNNoise</button>
                <button class="btn btn-danger" id="cancelBtn" style="display: none;">Cancel</button>
            </div>
            
            <div class="comparison">
                <div class="comparison-item">
                    <h3>Original Audio</h3>
                    <audio id="originalAudio" controls></audio>
                </div>
                <div class="comparison-item">
                    <h3>Processed Audio</h3>
                    <audio id="processedAudio" controls></audio>
                </div>
            </div>
            
            <div class="control-group">
                <button class="btn btn-success" id="downloadBtn" style="display: none;">Download Processed Audio</button>
            </div>
        </div>
        
        <div class="progress-container" id="progressContainer">
            <div class="status-text" id="statusText">Initializing...</div>
            <div class="progress-bar">
                <div class="progress" id="progressBar"></div>
            </div>
        </div>
        
        <div class="log-output" id="logOutput"></div>
    </div>

    <!-- Load the RNNoise WebAssembly module -->
    <script type="module">
        // Import your exact RNNoise module
        import createRNNoiseModule from './rnnoise-wasm.js';
        
        // WAV file reading functions (same as CLI.js)
        function readString(view, offset, length) {
            let str = '';
            for (let i = 0; i < length; i++) str += String.fromCharCode(view.getUint8(offset + i));
            return str;
        }

        function readWavFile(buffer) {
            const view = new DataView(buffer);
            
            if (readString(view, 0, 4) !== 'RIFF' || readString(view, 8, 4) !== 'WAVE') {
                throw new Error('Invalid WAV file');
            }
            
            let offset = 12, fmtOffset = -1;
            while (offset < view.byteLength - 8) {
                const chunkID = readString(view, offset, 4);
                const chunkSize = view.getUint32(offset + 4, true);
                if (chunkID === 'fmt ') {
                    fmtOffset = offset + 8;
                    break;
                }
                offset += 8 + chunkSize;
            }
            
            if (fmtOffset === -1) throw new Error('fmt chunk not found');
            
            const sampleRate = view.getUint32(fmtOffset + 4, true);
            const channels = view.getUint16(fmtOffset + 2, true);
            const bitsPerSample = view.getUint16(fmtOffset + 14, true);
            
            offset = 12;
            let dataOffset = -1, dataSize = 0;
            while (offset < view.byteLength - 8) {
                const chunkID = readString(view, offset, 4);
                const chunkSize = view.getUint32(offset + 4, true);
                if (chunkID === 'data') {
                    dataOffset = offset + 8;
                    dataSize = chunkSize;
                    break;
                }
                offset += 8 + chunkSize;
            }
            
            if (dataOffset === -1) throw new Error('data chunk not found');
            
            const samples = dataSize / (bitsPerSample / 8) / channels;
            const audioData = new Float32Array(samples);
            
            let sampleIndex = 0;
            for (let i = 0; i < dataSize; i += (bitsPerSample / 8) * channels) {
                if (bitsPerSample === 16) {
                    audioData[sampleIndex++] = view.getInt16(dataOffset + i, true) / 32768.0;
                    if (channels > 1) i += (bitsPerSample / 8) * (channels - 1);
                }
            }
            
            return { audioData, sampleRate };
        }

        // RNNoise processor (EXACT same logic as CLI.js)
        class RNNoiseProcessor {
            constructor() {
                this.module = null;
                this.rnnoise = null;
                this.frameSize = 480;
                this.isProcessing = false;
                this.progressCallback = null;
                this.logCallback = null;
            }

            async init() {
                this.log('ðŸ”§ Initializing RNNoise...');
                this.module = await createRNNoiseModule();
                this.rnnoise = this.module._rnnoise_create_wasm();
                this.frameSize = this.module._get_frame_size();
                this.log('âœ… RNNoise ready');
            }

            processFrame(inputFrame) {
                const inputPtr = this.module._malloc(this.frameSize * 4);
                const outputPtr = this.module._malloc(this.frameSize * 4);

                try {
                    // CRITICAL: Scale audio
                    const scaledInput = new Float32Array(this.frameSize);
                    for (let i = 0; i < inputFrame.length; i++) {
                        scaledInput[i] = inputFrame[i] * 32768.0; // Scale to int16 range
                    }

                    const inputBytes = new Uint8Array(scaledInput.buffer);
                    this.module.HEAPU8.set(inputBytes, inputPtr);
                    
                    const vad = this.module._rnnoise_process_frame_wasm(this.rnnoise, outputPtr, inputPtr);
                    
                    // CRITICAL: Get processed audio
                    const processedFrame = new Float32Array(this.frameSize);
                    const outputStart = outputPtr / 4;
                    for (let i = 0; i < this.frameSize; i++) {
                        processedFrame[i] = this.module.HEAPF32[outputStart + i];
                    }

                    // CRITICAL: Apply gain and scaling
                    const RNNOISE_GAIN = 0.95;
                    const finalFrame = new Float32Array(inputFrame.length);
                    for (let i = 0; i < inputFrame.length; i++) {
                        let sample = processedFrame[i] * RNNOISE_GAIN / 32768.0;
                        // Clipping
                        if (sample > 1.0) sample = 1.0;
                        else if (sample < -1.0) sample = -1.0;
                        finalFrame[i] = sample;
                    }

                    return { vad, audio: finalFrame };
                    
                } finally {
                    this.module._free(inputPtr);
                    this.module._free(outputPtr);
                }
            }

            setProgressCallback(callback) {
                this.progressCallback = callback;
            }
            
            setLogCallback(callback) {
                this.logCallback = callback;
            }
            
            log(message) {
                if (this.logCallback) {
                    this.logCallback(message);
                } else {
                    console.log(message);
                }
            }

            async processAudio(audioData) {
                this.isProcessing = true;
                const processed = [];
                let warmupFrames = 2;

                const totalFrames = Math.ceil(audioData.length / this.frameSize);
                
                for (let i = 0; i < audioData.length; i += this.frameSize) {
                    if (!this.isProcessing) {
                        this.log('âŒ Processing cancelled');
                        return null;
                    }
                    
                    const frame = audioData.slice(i, i + this.frameSize);
                    
                    if (frame.length < this.frameSize) {
                        // Incomplete frame - pad with zeros (exactly as CLI.js)
                        const paddedFrame = new Float32Array(this.frameSize);
                        paddedFrame.set(frame);
                        const result = this.processFrame(paddedFrame);
                        processed.push(...result.audio.slice(0, frame.length));
                    } else {
                        const result = this.processFrame(frame);
                        
                        // CRITICAL: Warm-up
                        if (warmupFrames > 0) {
                            // During warm-up, use original audio (not processed)
                            processed.push(...frame);
                            warmupFrames--;
                            this.log(`Warm-up frame ${3 - warmupFrames}/2`);
                        } else {
                            // After warm-up, use processed audio
                            processed.push(...result.audio);
                        }
                    }
                    
                    // Update progress
                    const currentFrame = Math.floor(i / this.frameSize);
                    const percent = ((i / audioData.length) * 100).toFixed(1);
                    
                    if (this.progressCallback) {
                        this.progressCallback(percent, currentFrame, totalFrames);
                    }
                    
                    if (currentFrame > 0 && currentFrame % 100 === 0) {
                        this.log(`ðŸ“ˆ ${percent}% processed (frame ${currentFrame}/${totalFrames})`);
                    }
                    
                    // Allow UI updates
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
                
                this.isProcessing = false;
                return Float32Array.from(processed);
            }

            cancel() {
                this.isProcessing = false;
            }

            destroy() {
                if (this.module && this.rnnoise) {
                    this.module._rnnoise_destroy_wasm(this.rnnoise);
                }
            }
        }

        // HTML elements
        const uploadSection = document.getElementById('uploadSection');
        const audioFileInput = document.getElementById('audioFileInput');
        const selectFileBtn = document.getElementById('selectFileBtn');
        const errorMessage = document.getElementById('errorMessage');
        const fileInfo = document.getElementById('fileInfo');
        const audioControls = document.getElementById('audioControls');
        const processBtn = document.getElementById('processBtn');
        const cancelBtn = document.getElementById('cancelBtn');
        const originalAudio = document.getElementById('originalAudio');
        const processedAudio = document.getElementById('processedAudio');
        const downloadBtn = document.getElementById('downloadBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const statusText = document.getElementById('statusText');
        const logOutput = document.getElementById('logOutput');
        
        let processor;
        let originalAudioData;
        let processedAudioData;
        let audioSampleRate;

        // Event listeners
        selectFileBtn.addEventListener('click', () => {
            audioFileInput.click();
        });
        
        audioFileInput.addEventListener('change', handleFileSelect);
        
        // Drag and drop
        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });
        
        uploadSection.addEventListener('dragleave', () => {
            uploadSection.classList.remove('dragover');
        });
        
        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                handleFile(e.dataTransfer.files[0]);
            }
        });
        
        processBtn.addEventListener('click', processAudio);
        cancelBtn.addEventListener('click', cancelProcessing);
        downloadBtn.addEventListener('click', downloadProcessedAudio);
        
        // Functions
        function handleFileSelect(e) {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        }
        
        function handleFile(file) {
            hideError();
            
            if (!file.name.toLowerCase().endsWith('.wav')) {
                showError('Please select a WAV file.');
                return;
            }
            
            fileInfo.textContent = `Selected: ${file.name} (${formatFileSize(file.size)})`;
            audioControls.style.display = 'block';
            downloadBtn.style.display = 'none';
            
            // Create blob URL for audio element
            const fileBlob = new Blob([file], { type: 'audio/wav' });
            originalAudio.src = URL.createObjectURL(fileBlob);
            
            // Read WAV file data for processing
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const wavData = readWavFile(e.target.result);
                    originalAudioData = wavData.audioData;
                    audioSampleRate = wavData.sampleRate;
                    
                    fileInfo.textContent += ` | ${audioSampleRate}Hz, ${(originalAudioData.length / audioSampleRate).toFixed(2)}s`;
                } catch (err) {
                    showError('Error reading WAV file: ' + err.message);
                }
            };
            
            reader.onerror = function() {
                showError('Error reading the selected file.');
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        async function processAudio() {
            if (!originalAudioData) {
                showError('No audio file loaded.');
                return;
            }
            
            try {
                processBtn.disabled = true;
                cancelBtn.style.display = 'inline-block';
                progressContainer.style.display = 'block';
                logOutput.style.display = 'block';
                logOutput.textContent = '';
                
                processor = new RNNoiseProcessor();
                
                // Set up logging
                processor.setLogCallback((message) => {
                    logOutput.textContent += `${new Date().toLocaleTimeString()}: ${message}\n`;
                    logOutput.scrollTop = logOutput.scrollHeight;
                });
                
                // Set up progress tracking
                processor.setProgressCallback((percent, currentFrame, totalFrames) => {
                    progressBar.style.width = `${percent}%`;
                    statusText.textContent = `Processing: ${percent}% (${currentFrame}/${totalFrames} frames)`;
                });
                
                await processor.init();
                
                // Start processing
                statusText.textContent = 'Processing with RNNoise...';
                logOutput.textContent += `${new Date().toLocaleTimeString()}: ðŸš€ Starting RNNoise processing\n`;
                logOutput.textContent += `${new Date().toLocaleTimeString()}: Using warm-up (2 frames) exactly as in C code\n`;
                
                const rawProcessedAudioData = await processor.processAudio(originalAudioData);

                processedAudioData = setProcessedAudio(
                    processedAudio,
                    rawProcessedAudioData,
                    audioSampleRate
                );

                if (processedAudioData) {
                    // Create WAV file from processed audio
                    const wavBlob = createWavFile(processedAudioData, audioSampleRate);
                    processedAudio.src = URL.createObjectURL(wavBlob);
                    
                    // Show download button
                    downloadBtn.style.display = 'inline-block';
                    
                    logOutput.textContent += `${new Date().toLocaleTimeString()}: âœ… RNNoise processing completed!\n`;
                    statusText.textContent = 'Processing completed!';
                    progressBar.style.width = '100%';
                }
            } catch (err) {
                showError('Error processing audio: ' + err.message);
                logOutput.textContent += `${new Date().toLocaleTimeString()}: âŒ Error: ${err.message}\n`;
            } finally {
                processBtn.disabled = false;
                cancelBtn.style.display = 'none';
                
                if (processor) {
                    processor.destroy();
                }
            }
        }
        
        function cancelProcessing() {
            if (processor) {
                processor.cancel();
                cancelBtn.style.display = 'none';
                statusText.textContent = 'Processing cancelled';
            }
        }
        
        function downloadProcessedAudio() {
            if (!processedAudioData) {
                showError('No processed audio available.');
                return;
            }
            
            // Create the WAV file using the same function as playback
            const wavBlob = createWavFile(processedAudioData, audioSampleRate);
            const url = URL.createObjectURL(wavBlob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'processed_audio.wav';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            // Clean up URL after download
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);
        }
        
        function sanitizeAudioBuffer(inputBuffer) {
            const output = new Float32Array(inputBuffer.length);

            for (let i = 0; i < inputBuffer.length; i++) {
                let sample = inputBuffer[i];

                if (!Number.isFinite(sample)) {
                    sample = 0.0;
                }

                if (sample > 1.0) {
                    sample = 1.0;
                } else if (sample < -1.0) {
                    sample = -1.0;
                }

                output[i] = sample;
            }

            return output;
        }

        function createWavFile(audioData, sampleRate) {
            const numSamples = audioData.length;
            const buffer = new ArrayBuffer(44 + numSamples * 2);
            const view = new DataView(buffer);

            function writeString(offset, str) {
                for (let i = 0; i < str.length; i++) {
                    view.setUint8(offset + i, str.charCodeAt(i));
                }
            }

            // RIFF header
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + numSamples * 2, true);
            writeString(8, 'WAVE');

            // fmt chunk
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true); // PCM
            view.setUint16(20, 1, true);  // Linear PCM
            view.setUint16(22, 1, true);  // Mono
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);

            // data chunk - FIXED: Use little-endian consistently
            writeString(36, 'data');
            view.setUint32(40, numSamples * 2, true);

            // FIXED: Better audio data conversion
            let offset = 44;
            for (let i = 0; i < numSamples; i++) {
                // Proper scaling and clamping
                let sample = Math.max(-1, Math.min(1, audioData[i]));
                // Convert to 16-bit PCM (-32768 to 32767)
                sample = sample < 0 ? sample * 32768 : sample * 32767;
                view.setInt16(offset, sample, true); // true for little-endian
                offset += 2;
            }

            return new Blob([buffer], { type: 'audio/wav' });
        }
        
        function setProcessedAudio(audioElement, rawProcessedBuffer, sampleRate) {
            const safeBuffer = sanitizeAudioBuffer(rawProcessedBuffer);
            const wavBlob = createWavFile(safeBuffer, sampleRate);

            const url = URL.createObjectURL(wavBlob);
            audioElement.src = url;
            audioElement.load();

            // Return the sanitized buffer for download
            return safeBuffer;
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
        }
        
        function hideError() {
            errorMessage.style.display = 'none';
        }
        
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' bytes';
            else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
            else return (bytes / 1048576).toFixed(1) + ' MB';
        }
    </script>

    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js')
            .then(() => console.log('Service Worker successfully registered.'))
            .catch(err => console.error('Erro SW:', err));
        }
    </script>
</body>
</html>
